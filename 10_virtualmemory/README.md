# チュートリアル10 - 仮想記憶

最も簡単で、かつ最も難しいチュートリアルにやってきました。やるべきことは配列を
埋め、いくつかのレジスタを設定するだけなので簡単です。難しいのは、その配列に
どんな値を入れるべきかを知ることです。

ここでは皆さんがAMD64のページ変換機構について十分な知識を持っていると仮定します。
そうでなければ、先に進む前にそれに関するチュートリアルを受けることを強く勧めます。
ARMv8のMMUはAMD64のMMUよりもはるかに複雑で多機能です。ARMv８(から始めるのは絶対に
良くありません。

AMD64のアドレス変換は非常にシンプルで、ページングテーブルレジスタが一つあり、
メモリは4レベルの4kページに分割され、アドレス空間には明確に定義された穴が一つ
あります。ARMv8はずっと強力です。ページフレームのサイズ、変換レベルの数を設定
でき、あるレベルの変換テーブルを連結することができ、さらには穴のサイズさえも
設定できます。これらすべてを一回のチュートリアルでカバーするのは不可能です。
そこで今回は、ARMv8のMMUをできるだけAMD64のMMUと同じになるように設定します。
つまり、4Kページフレームで2Mブロックと512Gのアドレス空間（3レベル）を構成し、
第4レベルは2つのレジスタに置きます。これを次のように考えます。AMD64では
CR3により参照される第4レベルのテーブルがありますが、ARMv8では、第4レベルの
テーブルの最初のエントリを保持するTTBR0レジスタとテーブルの最後の512番目の
エントリを保持するTTBR1があるので第4レベルのテーブルは不要となり、その間の
すべて（2番目から511番目のエントリでマッピングされるメモリ）は穴の中にある、
言い換えれば、それらは非カノニカルアドレスであると考えます。

ページ変換テーブルは同じように見えます。各レベルには物理アドレスと属性ビットを
持つ64ビットのエントリがあります。しかし、ARMv8でははるかに多くのオプションが
あります。キャッシュ可能性、共有可能性、アクセス可能性なども設定することが
できます。また、ページ属性配列を保持する特別なレジスタがあり、ページ変換属性の
ビットでそれをインデックス化することができます。

仮想アドレス空間を次のように変換します。下半分は、4kフレームでマッピングする
最初のブロックを除いて、2Mブロックで恒等マッピングします。上半分の-2Mには
UART0のMMIOをマッピングします。

あまり明らかではないかもしれませんが、変換ツリーは個々のページを指し示すことが
できます。ただし、これをC言語で処理するのは悪夢のようなことなので、ここでは
ちょっとした工夫をします。1つの連続したメモリ領域を使ってすべての変換テーブルを
作成し、1つの"paging"配列でアクセスするようにします。ページサイズとして4kを
選択し、1つの変換エントリは8バイトであるため、各ページには512エントリがある
ことになります。したがって、インデックス0～511は第1ページに、512～1023は
第2ページにあることになります。言い換えれば、paging[0]のアドレスは`_end`
(第1ページ)、paging[512]のアドレスは`_end + PAGESIZE`(第2ページ目)に等しい
ことになります。

## mmu.h, mmu.c

`mmu_init()`は、メモリ管理ユニットを初期化する関数です。peging配列を設定し、それを
使用するようCPUに伝えます。

## start

今回もシステム制御レジスタへのアクセス権限を与える必要があります。

## link.ld

今回は、dataラベルとendラベルをページアライメントにする必要があります。

## main

ページ変換を設定し、恒等マップしたMMIOと高位アドレスにマップしたMMIOの双方を
コンソールに出力します。

## 実行結果

```
$ make run
qemu-system-aarch64 -M raspi3 -kernel kernel8.img -serial stdio
page 1: 0x0000000000082000
page 2: 0x0000000000083000
page 3: 0x0000000000084000
page 4: 0x0000000000085000
page 5: 0x0000000000086000
page 6: 0x0000000000087000

paging[0        ] UL1[0]  : 0x0000000000084743  // 下12ビットは属性フラグ
paging[512+511  ] KL1[511]: 0x0000000000086703
paging[2*512    ] UL2[0]  : 0x0000000000085743
paging[2*512+1  ] UL2[1]  : 0x0040000000200741  // 上12ビットは属性フラグ
paging[2*512+511] UL2[511]: 0x004000003FE00645
paging[3*512    ] UL3[0]  : 0x0040000000000743
paging[3*512+1]   UL3[1]  : 0x0040000000001743
paging[3*512+511] UL3[511]: 0x00400000001FF743
paging[4*512+511] KL2[511]: 0x0000000000087703
paging[5*512    ] KL3[0]  : 0x004000003F201607

Writing through identity mapped MMIO.
Writing through MMIO mapped in higher half!
```

## メモ

### paging配列

```
1ページ [0    -      511] : ユーザ   L1, [0]のみ割り当て
   [0]                    : ユーザL2の先頭アドレス
2ページ [1*512-1*512+511] : カーネル L1, [512+511]のみ割り当て
   [511]                  : カーネルL2の先頭アドレス
3ページ [2*512-2*512+511] : ユーザ   L2, [0-511]を割り当て
   [2*512]                : ユーザL3の先頭アドレス
   [2*512+1 - 2*512+511]  : 2MB-1GBの物理アドレスの恒等変換（2Mブロック）
4ページ [3*512-3*512+511] : ユーザ   L3, [0-511]を割り当て
   [3*512   - 3*512+511]  : 0-2MBの物理アドレスの恒等変換
5ページ [4*512-4*512+511] : カーネル L2, [4*512+511]のみ割り当て
   [4*512+511]            : カーネルL3の先頭アドレス
6ページ [5*512-5*512+511] : カーネル L3, [5*512]のみ割り当て
   [5*512]                : MMIO_BASE+0x00201000: UART0のベースアドレス
```

## 参考資料

- [ARM AArch64のMMU](https://qiita.com/eggman/items/a8862d165cc0b4965f70)
